{"version":3,"file":"static/js/727.9964ea4e.chunk.js","mappings":"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","sources":["pages/ScanTome/ScanTome.jsx","components/Ost/Ost.jsx","components/ScanBar/ScanBar.jsx"],"sourcesContent":["import React, { useEffect, useState, useCallback, useRef } from 'react';\r\nimport { useParams, useNavigate } from 'react-router-dom';\r\nimport './ScanTome.css';\r\nimport ScanBar from '../../components/ScanBar/ScanBar';\r\nimport Loading from '../../components/Loading/Loading';\r\n\r\nconst ScanTome = () => {\r\n    const { tomelist, tomenumber, selectedpagetome } = useParams();\r\n    const navigate = useNavigate();\r\n    const [allPages, setAllPages] = useState([]);\r\n    const [scansInfo, setScansInfo] = useState([]);\r\n    const [loading, setLoading] = useState(true);\r\n    const [preloading, setPreloading] = useState(false);\r\n    const [progress, setProgress] = useState(0);\r\n    const [error, setError] = useState(null);\r\n    const [verticalScan, setVerticalScan] = useState(false);\r\n    const [isFullScreen, setIsFullScreen] = useState(false);\r\n    const [currentPageInput, setCurrentPageInput] = useState(selectedpagetome || 1);\r\n    const [tomeData, setTomeData] = useState(null);\r\n    const [preloadedPages, setPreloadedPages] = useState({});\r\n    const preloadingActive = useRef(false);\r\n\r\n    // Audio pour la page \"To Be Continued\"\r\n    const [audio] = useState(new Audio('https://kpiece2.s3.eu-west-3.amazonaws.com/ost/tobecontinued.mp3'));\r\n\r\n    // Gestion du mode plein écran\r\n    const handleFullScreen = () => {\r\n        if (!document.fullscreenElement) {\r\n            document.documentElement.requestFullscreen()\r\n                .then(() => {\r\n                    setIsFullScreen(true);\r\n                    document.body.classList.add('fullscreen-mode');\r\n                })\r\n                .catch(err => console.error(`Erreur lors de l'activation du plein écran : ${err.message}`));\r\n        } else if (document.exitFullscreen) {\r\n            document.body.classList.remove('fullscreen-mode');\r\n            document.exitFullscreen();\r\n            setIsFullScreen(false);\r\n        }\r\n    };\r\n\r\n    // Gestion de la vue verticale\r\n    const handleVerticalScan = () => setVerticalScan(prev => !prev);\r\n\r\n    // Gestion de l'audio pour la page \"To Be Continued\"\r\n    useEffect(() => {\r\n        if (!loading && allPages.length > 0) {\r\n            const maxPage = allPages.length;\r\n            const isLastPage = parseInt(selectedpagetome) === maxPage + 1;\r\n\r\n            if (isLastPage) {\r\n                audio.volume = 0.05; // Volume à 5%\r\n                audio.currentTime = 0; // Réinitialisation\r\n                audio.play().catch(err => console.error('Échec de la lecture audio :', err));\r\n            }\r\n        }\r\n    }, [selectedpagetome, allPages, loading, audio]);\r\n\r\n    // Contenu personnalisé pour la dernière page\r\n    const getCustomPageContent = () => (\r\n        <div className=\"last-page\">\r\n            <h2> TO BE CONTINUED... </h2>\r\n            <div className=\"bouton-last-page next-tome\">\r\n                <button onClick={handleNextTome}>\r\n                    <i className=\"fa-solid fa-arrow-right\"></i> Tome suivant\r\n                </button>\r\n            </div>\r\n            <div className=\"bouton-last-page back-page\">\r\n                <button onClick={handleReturnToReading}>\r\n                    <i className=\"fa-solid fa-arrow-left\"></i> RETOUR\r\n                </button>\r\n            </div>\r\n            <div className=\"bouton-last-page back-tome\">\r\n                <button onClick={handlePrevTome}>\r\n                    <i className=\"fa-solid fa-arrow-left\"></i> Tome précédent\r\n                </button>\r\n            </div>\r\n        </div>\r\n    );\r\n\r\n    const isCustomPage = (page, maxPageNum) => page === maxPageNum + 1;\r\n\r\n    // Fonction pour charger une seule image\r\n    const loadImage = (page) => {\r\n        return new Promise((resolve) => {\r\n            if (preloadedPages[page.pageNum]) {\r\n                resolve(true);\r\n                return;\r\n            }\r\n\r\n            const img = new Image();\r\n            img.src = page.url;\r\n            img.onload = () => {\r\n                setPreloadedPages(prev => ({...prev, [page.pageNum]: true}));\r\n                resolve(true);\r\n            };\r\n            img.onerror = () => {\r\n                setPreloadedPages(prev => ({...prev, [page.pageNum]: false}));\r\n                resolve(false);\r\n            };\r\n        });\r\n    };\r\n\r\n    // Préchargement initial des pages essentielles\r\n    const preloadInitialImages = useCallback(async (pages, currentPageNum) => {\r\n        if (!pages || pages.length === 0) return;\r\n        \r\n        setPreloading(true);\r\n        const currentIndex = parseInt(currentPageNum) - 1;\r\n        \r\n        // Déterminer les indices des pages à charger initialement\r\n        const indicesToLoad = [];\r\n        // Page courante\r\n        if (currentIndex >= 0 && currentIndex < pages.length) {\r\n            indicesToLoad.push(currentIndex);\r\n        }\r\n        \r\n        // 2 pages avant et 5 pages après\r\n        for (let i = 1; i <= 2; i++) {\r\n            if (currentIndex - i >= 0) {\r\n                indicesToLoad.push(currentIndex - i);\r\n            }\r\n        }\r\n        \r\n        for (let i = 1; i <= 5; i++) {\r\n            if (currentIndex + i < pages.length) {\r\n                indicesToLoad.push(currentIndex + i);\r\n            }\r\n        }\r\n        \r\n        // Charger ces pages\r\n        const pagesToLoad = indicesToLoad.map(idx => pages[idx]);\r\n        const totalToLoad = pagesToLoad.length;\r\n        let loadedCount = 0;\r\n        \r\n        for (const page of pagesToLoad) {\r\n            await loadImage(page);\r\n            loadedCount++;\r\n            setProgress(Math.floor((loadedCount / totalToLoad) * 100));\r\n        }\r\n        \r\n        setPreloading(false);\r\n    }, []);\r\n\r\n    // Préchargement en arrière-plan de pages supplémentaires\r\n    const preloadNextBatch = useCallback(async (pages, currentPageNum, batchSize = 5) => {\r\n        if (!pages || pages.length === 0 || preloadingActive.current) return;\r\n        \r\n        preloadingActive.current = true;\r\n        const currentIndex = parseInt(currentPageNum) - 1;\r\n        \r\n        // Déterminer les indices des pages suivantes à charger\r\n        const startIndex = currentIndex + 6; // Commencer après les 5 pages déjà chargées\r\n        const endIndex = Math.min(startIndex + batchSize - 1, pages.length - 1);\r\n        \r\n        // Si toutes les pages sont déjà préchargées\r\n        if (startIndex > endIndex) {\r\n            preloadingActive.current = false;\r\n            return;\r\n        }\r\n        \r\n        // Charger ces pages\r\n        const pagesToLoad = [];\r\n        for (let i = startIndex; i <= endIndex; i++) {\r\n            if (!preloadedPages[pages[i].pageNum]) {\r\n                pagesToLoad.push(pages[i]);\r\n            }\r\n        }\r\n        \r\n        if (pagesToLoad.length === 0) {\r\n            preloadingActive.current = false;\r\n            return;\r\n        }\r\n        \r\n        // Mise à jour visuelle du progrès (facultatif)\r\n        const totalLoaded = Object.keys(preloadedPages).length;\r\n        const totalPages = pages.length;\r\n        setProgress(Math.floor((totalLoaded / totalPages) * 100));\r\n        \r\n        // Charger en arrière-plan\r\n        const promises = pagesToLoad.map(page => loadImage(page));\r\n        await Promise.all(promises);\r\n        \r\n        // Mise à jour finale du progrès\r\n        const newTotalLoaded = Object.keys(preloadedPages).length;\r\n        setProgress(Math.floor((newTotalLoaded / totalPages) * 100));\r\n        \r\n        preloadingActive.current = false;\r\n    }, [preloadedPages]);\r\n\r\n    useEffect(() => {\r\n        const fetchTomeData = async () => {\r\n            try {\r\n                const response = await fetch(`https://kpiece2.s3.eu-west-3.amazonaws.com/data/tomes/${tomelist}.json`);\r\n                if (!response.ok) throw new Error('Échec de la récupération des données du tome');\r\n                const tomes = await response.json();\r\n                // Trier les tomes par numéro en ordre croissant\r\n                tomes.sort((a, b) => a.tome - b.tome);\r\n                const currentTome = tomes.find(t => t.tome === parseInt(tomenumber));\r\n                if (!currentTome) throw new Error('Tome non trouvé');\r\n                const tomeIndex = tomes.findIndex(t => t.tome === parseInt(tomenumber));\r\n                const prevTome = tomeIndex > 0 ? tomes[tomeIndex - 1].tome : null;\r\n                const nextTome = tomeIndex < tomes.length - 1 ? tomes[tomeIndex + 1].tome : null;\r\n                setTomeData({ ...currentTome, prevTome, nextTome });\r\n\r\n                const searchResponse = await fetch('https://kpiece2.s3.eu-west-3.amazonaws.com/data/search.json');\r\n                if (!searchResponse.ok) throw new Error('Échec de la récupération des données de recherche');\r\n                const searchData = await searchResponse.json();\r\n\r\n                const arcs = Array.isArray(currentTome.arc) ? currentTome.arc : [currentTome.arc];\r\n                let scans = [];\r\n                for (const arc of arcs) {\r\n                    const arcData = searchData.find(s => s.arc === arc);\r\n                    if (!arcData) continue;\r\n                    const start = Math.max(currentTome.firstscan, arcData.firstscan);\r\n                    const end = Math.min(currentTome.lastscan, arcData.lastscan);\r\n                    for (let scan = start; scan <= end; scan++) {\r\n                        scans.push({ saga: arcData.saga, arc, scan });\r\n                    }\r\n                }\r\n\r\n                if (scans.length === 0) throw new Error('Aucun scan trouvé pour ce tome');\r\n\r\n                let allPagesData = [];\r\n                let scanInfoArray = [];\r\n                \r\n                // Charger les métadonnées de toutes les pages\r\n                for (const scanInfo of scans) {\r\n                    const { saga, arc, scan } = scanInfo;\r\n                    const scanResponse = await fetch(`https://kpiece2.s3.eu-west-3.amazonaws.com/data/saga/${saga}/${arc}.json`);\r\n                    if (!scanResponse.ok) {\r\n                        console.error(`Échec de la récupération des données pour le scan ${scan}`);\r\n                        continue;\r\n                    }\r\n\r\n                    const arcData = await scanResponse.json();\r\n                    const scanData = arcData.find(s => s.scan === parseInt(scan));\r\n                    if (!scanData) {\r\n                        console.error(`Scan ${scan} non trouvé dans les données de l'arc`);\r\n                        continue;\r\n                    }\r\n\r\n                    const maxPages = scanData.maxpages;\r\n                    const pageStartIndex = allPagesData.length + 1;\r\n\r\n                    scanInfoArray.push({\r\n                        saga,\r\n                        arc,\r\n                        scan,\r\n                        name: scanData.name,\r\n                        startPage: pageStartIndex,\r\n                        endPage: pageStartIndex + maxPages - 1,\r\n                        maxpages: maxPages\r\n                    });\r\n\r\n                    for (let i = 1; i <= maxPages; i++) {\r\n                        const formattedPage = i < 10 ? `0${i}` : i;\r\n                        allPagesData.push({\r\n                            pageNum: allPagesData.length + 1,\r\n                            url: `https://kpiece2.s3.eu-west-3.amazonaws.com/scan/${saga}/${arc}/${scan}/${formattedPage}.png`,\r\n                            scanIndex: scanInfoArray.length - 1\r\n                        });\r\n                    }\r\n                }\r\n\r\n                setAllPages(allPagesData);\r\n                setScansInfo(scanInfoArray);\r\n                \r\n                // Charger d'abord la page actuelle et quelques pages environnantes\r\n                const currentPage = parseInt(selectedpagetome) || 1;\r\n                await preloadInitialImages(allPagesData, currentPage);\r\n                \r\n                setLoading(false);\r\n            } catch (error) {\r\n                console.error(\"Erreur lors de la récupération des données :\", error);\r\n                setError(error.message);\r\n                setLoading(false);\r\n            }\r\n        };\r\n\r\n        fetchTomeData();\r\n    }, [tomelist, tomenumber, preloadInitialImages]);\r\n\r\n    // Défilement après chargement\r\n    useEffect(() => {\r\n        if (!loading) window.scrollTo(0, 170);\r\n    }, [selectedpagetome, loading]);\r\n\r\n    // Mise à jour de l'entrée de page\r\n    useEffect(() => {\r\n        setCurrentPageInput(selectedpagetome || 1);\r\n    }, [selectedpagetome]);\r\n\r\n    // Précharger plus de pages quand l'utilisateur navigue\r\n    useEffect(() => {\r\n        if (!loading && allPages.length > 0 && selectedpagetome) {\r\n            const currentPage = parseInt(selectedpagetome);\r\n            // Précharger quelques pages supplémentaires\r\n            preloadNextBatch(allPages, currentPage, 5);\r\n        }\r\n    }, [selectedpagetome, loading, allPages, preloadNextBatch]);\r\n\r\n    // Composant de chargement\r\n    const LoadingComponent = () => {\r\n        if (preloading) {\r\n            return (\r\n                <div className=\"loading-container\">\r\n                    <div className=\"spinner\">\r\n                        <div className=\"double-bounce1\"></div>\r\n                        <div className=\"double-bounce2\"></div>\r\n                    </div>\r\n                    <p>Chargement des pages : {progress}%</p>\r\n                    <div className=\"scan-loading-progress-bar\">\r\n                        <div className=\"scan-loading-progress\" style={{ width: `${progress}%` }}></div>\r\n                    </div>\r\n                </div>\r\n            );\r\n        }\r\n        return <Loading />;\r\n    };\r\n\r\n    if (loading) return <LoadingComponent />;\r\n    if (error) return <div className=\"scan-page-error\">Tome Non disponible</div>;\r\n\r\n    const maxPage = allPages.length;\r\n    const currentPage = selectedpagetome && parseInt(selectedpagetome) <= maxPage + 1\r\n        ? parseInt(selectedpagetome)\r\n        : 1;\r\n    const showCustomPage = isCustomPage(parseInt(selectedpagetome), maxPage);\r\n    const isFinalView = currentPage > maxPage && !showCustomPage;\r\n\r\n    // Informations sur le scan actuel\r\n    const getCurrentScanInfo = () => {\r\n        if (!currentPage || currentPage > maxPage) return null;\r\n        return scansInfo[allPages[currentPage - 1]?.scanIndex];\r\n    };\r\n\r\n    const currentScanInfo = getCurrentScanInfo();\r\n\r\n    // Navigation vers une page spécifique\r\n    const navigateToPage = (page) => {\r\n        navigate(`/tomes/${tomelist}/${tomenumber}/${page}`);\r\n        \r\n        // Précharger silencieusement les pages adjacentes si elles ne sont pas déjà chargées\r\n        const pageNum = parseInt(page);\r\n        if (pageNum <= maxPage) {\r\n            const nextPage = pageNum < maxPage ? pageNum + 1 : null;\r\n            const prevPage = pageNum > 1 ? pageNum - 1 : null;\r\n            \r\n            if (nextPage && !preloadedPages[nextPage]) {\r\n                loadImage(allPages[nextPage - 1]);\r\n            }\r\n            \r\n            if (prevPage && !preloadedPages[prevPage]) {\r\n                loadImage(allPages[prevPage - 1]);\r\n            }\r\n        }\r\n    };\r\n\r\n    // Gestion des clics sur l'image\r\n    const handleImageClick = (e) => {\r\n        const rect = e.currentTarget.getBoundingClientRect();\r\n        const clickX = e.clientX - rect.left;\r\n        const width = rect.width;\r\n        if (clickX < width / 2) {\r\n            if (currentPage === 1) return;\r\n            navigateToPage(currentPage - 1);\r\n        } else {\r\n            if (currentPage === maxPage) {\r\n                navigateToPage(maxPage + 1);\r\n            } else {\r\n                navigateToPage(currentPage + 1);\r\n            }\r\n        }\r\n    };\r\n\r\n    const handlePrevTome = () => {\r\n        if (tomeData && tomeData.prevTome) navigate(`/tomes/${tomelist}/${tomeData.prevTome}/1`);\r\n    };\r\n\r\n    const handleNextTome = () => {\r\n        if (tomeData && tomeData.nextTome) navigate(`/tomes/${tomelist}/${tomeData.nextTome}/1`);\r\n    };\r\n\r\n    const handleReturnToReading = () => navigateToPage(maxPage);\r\n\r\n    const handlePageInputChange = (e) => {\r\n        if (/^\\d*$/.test(e.target.value)) setCurrentPageInput(e.target.value);\r\n    };\r\n\r\n    const handlePageInputBlur = () => {\r\n        const page = parseInt(currentPageInput, 10);\r\n        if (page >= 1 && page <= maxPage) navigateToPage(page);\r\n        else setCurrentPageInput(currentPage);\r\n    };\r\n\r\n    const handleKeyDown = (e) => {\r\n        if (e.key === 'Enter') handlePageInputBlur();\r\n    };\r\n\r\n    // Contenu affiché\r\n    let content = null;\r\n    if (verticalScan) {\r\n        content = allPages.map((page) => (\r\n            <img\r\n                key={page.pageNum}\r\n                src={page.url}\r\n                alt={`Page ${page.pageNum}`}\r\n                className=\"scan-page-image\"\r\n                loading=\"lazy\"\r\n            />\r\n        ));\r\n    } else if (showCustomPage) {\r\n        content = getCustomPageContent();\r\n    } else if (isFinalView) {\r\n        content = (\r\n            <div className=\"final-view\">\r\n                <button onClick={handlePrevTome}>\r\n                    <i className=\"fa-solid fa-arrow-left\"></i> Tome précédent\r\n                </button>\r\n                <button onClick={handleNextTome}>\r\n                    <i className=\"fa-solid fa-arrow-right\"></i> Tome suivant\r\n                </button>\r\n                <button onClick={handleReturnToReading}>\r\n                    <i className=\"fa-solid fa-arrow-left\"></i> Revenir à la lecture\r\n                </button>\r\n            </div>\r\n        );\r\n    } else {\r\n        const currentPageData = allPages[currentPage - 1];\r\n        content = (\r\n            <div className=\"image-container\" onClick={handleImageClick}>\r\n                <div className=\"left-half\" />\r\n                <div className=\"right-half\" />\r\n                <img\r\n                    src={currentPageData.url}\r\n                    alt={`Page ${currentPage}`}\r\n                    className=\"scan-page-image\"\r\n                />\r\n            </div>\r\n        );\r\n    }\r\n    \r\n    // Calculer le pourcentage réel de pages préchargées\r\n    const preloadedCount = Object.values(preloadedPages).filter(Boolean).length;\r\n    const preloadPercentage = maxPage > 0 ? Math.floor((preloadedCount / maxPage) * 100) : 0;\r\n\r\n    return (\r\n        <div className=\"scan-tome\">\r\n            <div className='top-scan-element'>\r\n                <div className=\"page-counter\">\r\n                    Page <input\r\n                        type=\"text\"\r\n                        value={currentPageInput}\r\n                        onChange={handlePageInputChange}\r\n                        onBlur={handlePageInputBlur}\r\n                        onKeyDown={handleKeyDown}\r\n                        style={{ width: '50px', textAlign: 'center' }}\r\n                    /> / {maxPage}\r\n                </div>\r\n                {currentScanInfo && (\r\n                    <div className=\"select-scan\">\r\n                        {/* Replace the current scan info with a scan selector */}\r\n                        <select\r\n                            value={currentScanInfo?.scan || ''}\r\n                            onChange={(e) => {\r\n                                const selectedScan = scansInfo.find(scan => scan.scan.toString() === e.target.value);\r\n                                if (selectedScan) {\r\n                                    navigateToPage(selectedScan.startPage);\r\n                                }\r\n                            }}\r\n                        >\r\n                            <option value=\"\" disabled> Tome {tomenumber} - {tomeData?.name || 'Chargement...'} </option>\r\n                            {scansInfo.map((scan, index) => (\r\n                                <option key={index} value={scan.scan}>\r\n                                   Chapitre {scan.scan} - {scan.name}\r\n                                </option>\r\n                            ))}\r\n                        </select>\r\n                    </div>\r\n                )}\r\n            </div>\r\n            {\r\n                !showCustomPage && (\r\n                    <ScanBar\r\n                        onFullScreen={handleFullScreen}\r\n                        onVerticalScan={handleVerticalScan}\r\n                        isFullScreen={isFullScreen}\r\n                    />\r\n                )\r\n            }\r\n            {content}\r\n            {\r\n                maxPage && !showCustomPage && !verticalScan && (\r\n                    <div className=\"page-progress-bar\">\r\n                        <div\r\n                            className=\"page-progress\"\r\n                            style={{ width: `${(currentPage / maxPage) * 100}%` }}\r\n                        ></div>\r\n                    </div>\r\n                )\r\n            }\r\n            {preloadPercentage < 100 && (\r\n                <div className=\"background-loading-indicator\" style={{\r\n                    position: 'fixed',\r\n                    bottom: '10px',\r\n                    right: '10px',\r\n                    background: 'rgba(0, 0, 0, 0.3)',\r\n                    color: 'white',\r\n                    padding: '5px 10px',\r\n                    borderRadius: '5px',\r\n                    fontSize: '10px',\r\n                    zIndex: 1000\r\n                }}>\r\n                    Pages chargées: {preloadedCount}/{maxPage} ({preloadPercentage}%)\r\n                </div>\r\n            )}\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default ScanTome;","import React, { useState, useRef, useEffect } from 'react';\r\nimport './Ost.css';\r\n\r\nconst Ost = () => {\r\n    // On supprime \"happy\" et on ne garde que les moods désirés\r\n    const [tracks, setTracks] = useState({\r\n        chill: [],\r\n        danger: [],\r\n        emotion: [],\r\n        epic: [],\r\n        fight: [],\r\n        fun: [],\r\n        mysterious: [],\r\n        sad: []\r\n    });\r\n\r\n    const [isOn, setIsOn] = useState(() => {\r\n        const savedIsOn = localStorage.getItem('ostIsOn');\r\n        return savedIsOn !== null ? JSON.parse(savedIsOn) : false;\r\n    });\r\n\r\n    const [volume, setVolume] = useState(() => {\r\n        const savedVolume = localStorage.getItem('ostVolume');\r\n        return savedVolume !== null ? JSON.parse(savedVolume) : 50;\r\n    });\r\n    const [currentMood, setCurrentMood] = useState('');\r\n    const [currentIndex, setCurrentIndex] = useState(0);\r\n    const [isLoading, setIsLoading] = useState(false);\r\n    const [isPlaying, setIsPlaying] = useState(false);\r\n    const [ostInfo, setOstInfo] = useState([]);\r\n    const audioRef = useRef(null);\r\n    const baseUrl = \"https://kpiece2.s3.eu-west-3.amazonaws.com/ost/\";\r\n\r\n    // Récupération du JSON ost.json\r\n    const fetchOstInfo = async () => {\r\n        try {\r\n            const response = await fetch(\"https://kpiece2.s3.eu-west-3.amazonaws.com/ost/ost.json\");\r\n            if (!response.ok) {\r\n                throw new Error(\"Failed to fetch OST info\");\r\n            }\r\n            const data = await response.json();\r\n            setOstInfo(data);\r\n            return data;\r\n        } catch (error) {\r\n            console.error(\"Error fetching OST info:\", error);\r\n            return [];\r\n        }\r\n    };\r\n\r\n    // Fonction pour jouer une piste aléatoire du mood actuel\r\n    const handleRandomTrack = () => {\r\n        if (currentMood && tracks[currentMood] && tracks[currentMood].length > 0) {\r\n            // Génère un index aléatoire différent de l'index actuel\r\n            let randomIndex;\r\n            do {\r\n                randomIndex = Math.floor(Math.random() * tracks[currentMood].length);\r\n            } while (randomIndex === currentIndex && tracks[currentMood].length > 1);\r\n\r\n            // Joue la piste aléatoire\r\n            playTrack(currentMood, randomIndex);\r\n        }\r\n    };\r\n\r\n    // Charge chaque piste sous forme d'objet { fileName, displayName }\r\n    const loadTracksForMood = async (mood, info = null) => {\r\n        setIsLoading(true);\r\n\r\n        // On utilise les infos déjà chargées sinon on les fetch\r\n        const data = info || ostInfo || await fetchOstInfo();\r\n\r\n        // Trouve l'objet décrivant le mood dans ost.json\r\n        const moodInfo = data.find(item => item.name === mood);\r\n        if (!moodInfo) {\r\n            console.error(`Aucune info trouvée pour le mood: ${mood}`);\r\n            setIsLoading(false);\r\n            return [];\r\n        }\r\n\r\n        // moodInfo.ostnumber = nombre de pistes\r\n        // moodInfo.ostname = tableau de titres (ex. [\"Mother Sea\", \"Gold and Oden\", …])\r\n        const moodTracks = moodInfo.ostname.map((title, idx) => ({\r\n            fileName: `${idx + 1}.mp3`,  // ex: \"1.mp3\", \"2.mp3\"…\r\n            displayName: title          // ex: \"Mother Sea\", …\r\n        }));\r\n\r\n        setTracks(prev => ({\r\n            ...prev,\r\n            [mood]: moodTracks\r\n        }));\r\n        setIsLoading(false);\r\n        return moodTracks;\r\n    };\r\n\r\n    // Joue la piste (index) du mood\r\n    const playTrack = async (mood, index) => {\r\n        // Allume l'OST si elle est éteinte\r\n        if (!isOn) {\r\n            setIsOn(true);\r\n        }\r\n        setIsLoading(true);\r\n\r\n        // Récupération des pistes pour le mood\r\n        let moodTracks = tracks[mood];\r\n        if (!moodTracks || moodTracks.length === 0) {\r\n            moodTracks = await loadTracksForMood(mood);\r\n        }\r\n\r\n        if (moodTracks && moodTracks.length > 0) {\r\n            // Gestion du débordement (index trop petit ou trop grand)\r\n            if (index >= moodTracks.length) {\r\n                index = 0;\r\n            } else if (index < 0) {\r\n                index = moodTracks.length - 1;\r\n            }\r\n\r\n            const trackObj = moodTracks[index];\r\n            const trackUrl = `${baseUrl}${mood}/${trackObj.fileName}`;\r\n\r\n            if (audioRef.current) {\r\n                audioRef.current.pause();\r\n                audioRef.current.src = trackUrl;\r\n                audioRef.current.volume = volume / 100;\r\n                audioRef.current.oncanplaythrough = () => {\r\n                    audioRef.current.play()\r\n                        .then(() => {\r\n                            setCurrentMood(mood);\r\n                            setCurrentIndex(index);\r\n                            setIsPlaying(true);\r\n                            setIsLoading(false);\r\n                        })\r\n                        .catch(error => {\r\n                            console.error(\"Erreur lors de la lecture:\", error);\r\n                            setIsPlaying(false);\r\n                            setIsLoading(false);\r\n                        });\r\n                };\r\n                audioRef.current.onerror = () => {\r\n                    console.error(`Erreur de chargement pour: ${trackUrl}`);\r\n                    setIsPlaying(false);\r\n                    setIsLoading(false);\r\n                };\r\n            }\r\n        } else {\r\n            console.error(`Aucune piste trouvée pour l'ambiance: ${mood}`);\r\n            setIsPlaying(false);\r\n            setIsLoading(false);\r\n        }\r\n    };\r\n\r\n    // Sélectionne un mood différent\r\n    const handleMoodClick = (mood) => {\r\n        if (currentMood !== mood) {\r\n            playTrack(mood, 0);\r\n        }\r\n    };\r\n\r\n    const handleNext = () => {\r\n        if (currentMood) {\r\n            playTrack(currentMood, currentIndex + 1);\r\n        }\r\n    };\r\n\r\n    const handlePrev = () => {\r\n        if (currentMood) {\r\n            playTrack(currentMood, currentIndex - 1);\r\n        }\r\n    };\r\n\r\n    const handleVolumeChange = (e) => {\r\n        const newVolume = e.target.value;\r\n        setVolume(newVolume);\r\n        localStorage.setItem('ostVolume', JSON.stringify(newVolume));\r\n        if (audioRef.current) {\r\n            audioRef.current.volume = newVolume / 100;\r\n        }\r\n    };\r\n\r\n    const handlePlayPause = () => {\r\n        if (audioRef.current) {\r\n            if (isPlaying) {\r\n                audioRef.current.pause();\r\n                setIsPlaying(false);\r\n            } else if (audioRef.current.src) {\r\n                audioRef.current.play()\r\n                    .then(() => {\r\n                        setIsPlaying(true);\r\n                    })\r\n                    .catch(error => {\r\n                        console.error(\"Erreur lors de la reprise de lecture:\", error);\r\n                    });\r\n            } else if (currentMood) {\r\n                playTrack(currentMood, currentIndex);\r\n            }\r\n        }\r\n    };\r\n\r\n    // Éteint l'OST quand isOn passe à false\r\n    useEffect(() => {\r\n        if (!isOn && audioRef.current) {\r\n            audioRef.current.pause();\r\n            setIsPlaying(false);\r\n        }\r\n    }, [isOn]);\r\n\r\n    // Au montage ou quand isOn change :\r\n    // charge l'ost.json et initialise les pistes\r\n    useEffect(() => {\r\n        if (isOn) {\r\n            const initializeOst = async () => {\r\n                setIsLoading(true);\r\n                const info = await fetchOstInfo();\r\n                // On précharge les pistes pour tous les moods\r\n                for (const moodItem of info) {\r\n                    await loadTracksForMood(moodItem.name, info);\r\n                }\r\n                setIsLoading(false);\r\n            };\r\n            initializeOst();\r\n        } else if (audioRef.current) {\r\n            audioRef.current.pause();\r\n            setIsPlaying(false);\r\n        }\r\n    }, [isOn]);\r\n\r\n    // Auto-play de la piste suivante quand la piste se termine\r\n    useEffect(() => {\r\n        if (audioRef.current) {\r\n            const handleTrackEnded = () => {\r\n                if (currentMood) {\r\n                    playTrack(currentMood, currentIndex + 1);\r\n                }\r\n            };\r\n            audioRef.current.addEventListener('ended', handleTrackEnded);\r\n            return () => {\r\n                if (audioRef.current) {\r\n                    audioRef.current.removeEventListener('ended', handleTrackEnded);\r\n                }\r\n            };\r\n        }\r\n    }, [currentMood, currentIndex]);\r\n\r\n    // Enregistre l'état On/Off dans localStorage\r\n    useEffect(() => {\r\n        localStorage.setItem('ostIsOn', JSON.stringify(isOn));\r\n    }, [isOn]);\r\n\r\n    return (\r\n        <div className=\"ost-player\">\r\n            <div className=\"ost-title\">OST</div>\r\n\r\n            <div className=\"switch-container\">\r\n                <label className=\"switch\">\r\n                    <input\r\n                        type=\"checkbox\"\r\n                        checked={isOn}\r\n                        onChange={() => setIsOn(!isOn)}\r\n                    />\r\n                    <span className=\"slider round\"></span>\r\n                </label>\r\n            </div>\r\n\r\n            {isOn && (\r\n                <>\r\n\r\n\r\n\r\n\r\n                    <div className=\"track-navigation\">\r\n                        <button\r\n                            className=\"prev-button\"\r\n                            onClick={handlePrev}\r\n                            disabled={!currentMood || isLoading}\r\n                        >\r\n                            <i className=\"fa-solid fa-backward-step\"></i>\r\n                        </button>\r\n\r\n\r\n                        <button\r\n                            className=\"play-pause-button\"\r\n                            onClick={handlePlayPause}\r\n                            disabled={isLoading || (!currentMood && !audioRef.current?.src)}\r\n                        >\r\n                            {isLoading ? (\r\n                                <i className=\"fa-solid fa-spinner fa-spin\"></i>\r\n                            ) : isPlaying ? (\r\n                                <i className=\"fa-solid fa-pause\"></i>\r\n                            ) : (\r\n                                <i className=\"fa-solid fa-play\"></i>\r\n                            )}\r\n                        </button>\r\n\r\n\r\n\r\n                        <button\r\n                            className=\"next-button\"\r\n                            onClick={handleNext}\r\n                            disabled={!currentMood || isLoading}\r\n                        >\r\n                            <i className=\"fa-solid fa-forward-step\"></i>\r\n                        </button>\r\n\r\n                        <button className='random-button'\r\n                            onClick={handleRandomTrack} \r\n                            disabled={!currentMood || isLoading}\r\n                    >\r\n                        <i className=\"fa-solid fa-shuffle\"></i>\r\n                        \r\n                    </button>\r\n                    </div>\r\n\r\n\r\n\r\n                    <div className=\"volume-container\">\r\n                        <input\r\n                            type=\"range\"\r\n                            min=\"0\"\r\n                            max=\"100\"\r\n                            value={volume}\r\n                            onChange={handleVolumeChange}\r\n                            className=\"volume-slider\"\r\n                        />\r\n                        {volume}%\r\n                    </div>\r\n\r\n                    <div className=\"mood-buttons\">\r\n                        {Object.keys(tracks).map(mood => (\r\n                            <button\r\n                                key={mood}\r\n                                className={\r\n                                    `mood-button ${currentMood === mood ? 'active' : ''\r\n                                    } ${isLoading && currentMood !== mood\r\n                                        ? 'disabled'\r\n                                        : ''\r\n                                    }`\r\n                                }\r\n                                onClick={() => handleMoodClick(mood)}\r\n                                disabled={isLoading && currentMood !== mood}\r\n                            >\r\n                                {mood.charAt(0).toUpperCase() + mood.slice(1)}\r\n                            </button>\r\n                        ))}\r\n                    </div>\r\n\r\n                    <div className=\"current-audio\">\r\n                        <p> <i className=\"fa-solid fa-music\"></i>\r\n                            {currentMood && tracks[currentMood] && tracks[currentMood][currentIndex]\r\n                                ? `  ${tracks[currentMood][currentIndex].displayName}.mp3`\r\n                                : 'Aucune Ost chargé'}\r\n                        </p>\r\n                    </div>\r\n\r\n                    <audio ref={audioRef} />\r\n                </>\r\n            )}\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default Ost;","import React from 'react';\r\nimport './ScanBar.css';\r\nimport Ost from '../Ost/Ost';\r\n\r\nfunction ScanBar({ onFullScreen, onVerticalScan }) {\r\n    const [verticalIcon, setVerticalIcon] = React.useState(true);\r\n\r\n    const handleVerticalScanClick = () => {\r\n        setVerticalIcon(!verticalIcon);\r\n        // Call the prop onVerticalScan, configured externally.\r\n        if (onVerticalScan) {\r\n            onVerticalScan();\r\n        }\r\n    };\r\n\r\n    // Create style object for scan-bar based on vertical mode\r\n    const scanBarStyle = !verticalIcon ? {\r\n        position: 'sticky',\r\n        top: 0,\r\n        background: 'black',\r\n        borderRadius: 0\r\n    } : {};\r\n\r\n    return (\r\n        <div className='scan-bar' style={scanBarStyle}>\r\n            <button onClick={onFullScreen} className='scan-bar-button'>\r\n                <i className=\"fa-solid fa-expand\"></i>\r\n            </button>\r\n            <button onClick={handleVerticalScanClick} className='scan-bar-button'>\r\n                <i className={`fa-solid ${verticalIcon ? 'fa-arrows-up-down' : 'fa-arrows-left-right'}`}></i>\r\n            </button>\r\n                <Ost />\r\n            \r\n        </div>\r\n    );\r\n}\r\n\r\nexport default ScanBar;\r\n"],"names":["ScanTome","tomelist","tomenumber","selectedpagetome","useParams","navigate","useNavigate","allPages","setAllPages","useState","scansInfo","setScansInfo","loading","setLoading","preloading","setPreloading","progress","setProgress","error","setError","verticalScan","setVerticalScan","isFullScreen","setIsFullScreen","currentPageInput","setCurrentPageInput","tomeData","setTomeData","preloadedPages","setPreloadedPages","preloadingActive","useRef","audio","Audio","useEffect","length","maxPage","parseInt","volume","currentTime","play","catch","err","console","loadImage","page","Promise","resolve","pageNum","img","Image","src","url","onload","prev","onerror","preloadInitialImages","useCallback","async","pages","currentPageNum","currentIndex","indicesToLoad","push","i","pagesToLoad","map","idx","totalToLoad","loadedCount","Math","floor","preloadNextBatch","batchSize","arguments","undefined","current","startIndex","endIndex","min","totalLoaded","Object","keys","totalPages","promises","all","newTotalLoaded","response","fetch","ok","Error","tomes","json","sort","a","b","tome","currentTome","find","t","tomeIndex","findIndex","prevTome","nextTome","searchResponse","searchData","arcs","Array","isArray","arc","scans","arcData","s","start","max","firstscan","end","lastscan","scan","saga","allPagesData","scanInfoArray","scanInfo","scanResponse","scanData","maxPages","maxpages","pageStartIndex","name","startPage","endPage","formattedPage","scanIndex","currentPage","message","fetchTomeData","window","scrollTo","LoadingComponent","_jsxs","className","children","_jsx","style","width","Loading","showCustomPage","isFinalView","currentScanInfo","getCurrentScanInfo","_allPages","navigateToPage","nextPage","prevPage","handleImageClick","e","rect","currentTarget","getBoundingClientRect","clientX","left","handlePrevTome","handleNextTome","handleReturnToReading","handlePageInputBlur","content","alt","onClick","currentPageData","preloadedCount","values","filter","Boolean","preloadPercentage","type","value","onChange","test","target","onBlur","onKeyDown","key","textAlign","selectedScan","toString","disabled","index","ScanBar","onFullScreen","handleFullScreen","document","fullscreenElement","exitFullscreen","body","classList","remove","documentElement","requestFullscreen","then","add","onVerticalScan","handleVerticalScan","position","bottom","right","background","color","padding","borderRadius","fontSize","zIndex","Ost","_audioRef$current","tracks","setTracks","chill","danger","emotion","epic","fight","fun","mysterious","sad","isOn","setIsOn","savedIsOn","localStorage","getItem","JSON","parse","setVolume","savedVolume","currentMood","setCurrentMood","setCurrentIndex","isLoading","setIsLoading","isPlaying","setIsPlaying","ostInfo","setOstInfo","audioRef","fetchOstInfo","data","loadTracksForMood","mood","info","moodInfo","item","moodTracks","ostname","title","fileName","displayName","playTrack","trackObj","trackUrl","pause","oncanplaythrough","moodItem","initializeOst","handleTrackEnded","addEventListener","removeEventListener","setItem","stringify","checked","_Fragment","handlePrev","handlePlayPause","handleNext","handleRandomTrack","randomIndex","random","newVolume","handleMoodClick","charAt","toUpperCase","slice","ref","_ref","verticalIcon","setVerticalIcon","React","scanBarStyle","top","handleVerticalScanClick"],"sourceRoot":""}